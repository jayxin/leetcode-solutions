#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

// 190. 颠倒 二进制位 - 颠倒给定的 32 位无符号整数的二进制位。
//  
// 示例 1：
// 输入：n = 43261596
// 输出：964176192
// 解释：
// 整数 二进制 43261596 00000010100101000001111010011100 964176192 00111001011110000010100101000000
// 示例 2：
// 输入：n = 2147483644
// 输出：1073741822
// 解释：
// 整数 二进制 2147483644 01111111111111111111111111111100 1073741822 00111111111111111111111111111110
//  
// 提示：
//  * 0 &lt;= n &lt;= 231 - 2
//  * n 为偶数
//  
// 进阶: 如果多次调用这个函数，你将如何优化你的算法？

//// #v1
//int reverseBits(int n) {
  //int ret = 0;
  //for (int i = 0; i < 32; i++) {
    //if ((n >> i) & 1) {
      //ret |= (1 << (31 - i));
    //}
  //}
  //return ret;
//}
//// #v1

// #v2
//void print_bin(int n) {
//  if (n) print_bin(n / 2);
//  if (n & 1) {
//    putchar('1');
//  } else {
//    putchar('0');
//  }
//}
// 分治
unsigned int reverseBits(unsigned int n) {
  int m1 = 0x55555555, // 0101
      m2 = 0x33333333, // 0011
      m3 = 0x0f0f0f0f, // 0000 1111
      m4 = 0x00ff00ff, // 0000 0000 1111 1111
      m5 = 0x0000ffff;

  // 1 位为单位翻转
  n = ((n >> 1) & m1) | ((n << 1) & ~m1);
  // 2 位为单位翻转
  n = ((n >> 2) & m2) | ((n << 2) & ~m2);
  // 4 位为单位翻转
  n = ((n >> 4) & m3) | ((n << 4) & ~m3);
  // 8 位为单位翻转
  n = ((n >> 8) & m4) | ((n << 8) & ~m4);
  // 16 位为单位翻转
  n = ((n >> 16) & m5) | ((n << 16) & ~m5);

  return n;
}
// #v2

int main(int argc, char *argv[])
{
  int n;
  scanf("%d", &n);
  printf("%d\n", reverseBits(n));
  return EXIT_SUCCESS;
}

/* vim: set fdm=marker fmr={,}: */
